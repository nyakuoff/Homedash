<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>HomeDash</title>
    <style>
        :root {
            --bg: #0b0f14;
            --panel: #0f1620;
            --panel2: #0c121b;
            --text: #e8eef6;
            --muted: #9fb0c5;
            --stroke: #1c2a3a;
            --accent: #4cc9f0;
            --danger: #ff4d6d;
            --r: 22px;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
            background: radial-gradient(1400px 900px at 20% 0%, #0f1b2a 0%, var(--bg) 55%);
            color: var(--text);
            font-size: 16px;
        }

        .wrap {
            max-width: 1320px;
            margin: 0 auto;
            padding: 28px
        }

        .top {
            display: flex;
            gap: 18px;
            align-items: flex-end;
            justify-content: space-between;
            padding: 22px;
            border: 1px solid var(--stroke);
            border-radius: var(--r);
            background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .02));
            backdrop-filter: blur(10px);
        }

        h1 {
            margin: 0;
            font-size: 28px;
            letter-spacing: .2px
        }

        .sub {
            margin: 8px 0 0;
            color: var(--muted);
            font-size: 14px
        }

        .actions {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap
        }

        .input {
            width: 320px;
            background: var(--panel2);
            border: 1px solid var(--stroke);
            color: var(--text);
            padding: 12px 14px;
            border-radius: 14px;
            outline: none;
            font-size: 15px;
        }

        .input:focus {
            border-color: rgba(76, 201, 240, .55);
            box-shadow: 0 0 0 5px rgba(76, 201, 240, .12)
        }

        .btn {
            border: 1px solid var(--stroke);
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            padding: 12px 14px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, .10)
        }

        .btn.ghost {
            background: transparent
        }

        .btn.danger {
            border-color: rgba(255, 77, 109, .45);
            color: #ffd0d9
        }

        .btn.danger:hover {
            background: rgba(255, 77, 109, .14)
        }

        .miniBtn {
            border: 1px solid var(--stroke);
            background: rgba(255, 255, 255, .05);
            color: var(--text);
            padding: 8px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 13px;
        }

        .miniBtn:hover {
            background: rgba(255, 255, 255, .09)
        }

        .miniBtn.danger {
            border-color: rgba(255, 77, 109, .45);
            color: #ffd0d9
        }

        .miniBtn.danger:hover {
            background: rgba(255, 77, 109, .14)
        }

        #content {
            margin-top: 18px;
            display: grid;
            gap: 16px
        }

        .group {
            border: 1px solid var(--stroke);
            border-radius: var(--r);
            background: rgba(255, 255, 255, .03);
            overflow: hidden;
        }

        .group.dragging {
            opacity: .65;
            outline: 2px solid rgba(76, 201, 240, .25);
        }

        .group.dropTarget {
            outline: 2px solid rgba(76, 201, 240, .35);
            box-shadow: 0 0 0 6px rgba(76, 201, 240, .10);
        }

        .groupHead {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: rgba(0, 0, 0, .14);
            border-bottom: 1px solid var(--stroke);
        }

        .groupTitle {
            font-size: 13px;
            color: var(--muted);
            letter-spacing: .25px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
            user-select: none;
        }

        .dragHandle {
            width: 34px;
            height: 34px;
            border-radius: 12px;
            border: 1px solid var(--stroke);
            background: rgba(255, 255, 255, .05);
            display: grid;
            place-items: center;
            cursor: grab;
            user-select: none;
        }

        .dragHandle:active {
            cursor: grabbing
        }

        .dragDots {
            width: 14px;
            height: 14px;
            background:
                radial-gradient(circle, rgba(232, 238, 246, .70) 2px, transparent 2px) 0 0/7px 7px;
            opacity: .85;
            border-radius: 4px;
        }

        .groupRight {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .groupCount {
            font-size: 13px;
            color: var(--muted);
            letter-spacing: .25px;
            text-transform: uppercase;
        }

        .gridCards {
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 14px;
            min-height: 24px;
        }

        .gridCards.dropTarget {
            outline: 2px dashed rgba(76, 201, 240, .35);
            outline-offset: -6px;
        }

        .card {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 14px;
            border-radius: 18px;
            border: 1px solid var(--stroke);
            background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .02));
            cursor: pointer;
            transition: transform .08s ease, background .12s ease, border-color .12s ease;
            user-select: none;
            min-height: 64px;
        }

        .card:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, .08);
            border-color: rgba(76, 201, 240, .28)
        }

        .card.dragging {
            opacity: .55;
            cursor: grabbing;
        }

        .card.placeholder {
            border: 2px dashed rgba(76, 201, 240, .35);
            background: rgba(76, 201, 240, .08);
            min-height: 64px;
        }

        .fav {
            width: 44px;
            height: 44px;
            border-radius: 16px;
            background: rgba(255, 255, 255, .07);
            border: 1px solid var(--stroke);
            display: grid;
            place-items: center;
            overflow: hidden;
            flex: 0 0 auto;
        }

        .fav img {
            width: 22px;
            height: 22px
        }

        .fav .letter {
            font-weight: 800;
            color: rgba(232, 238, 246, .92);
            font-size: 16px;
        }

        .meta {
            min-width: 0
        }

        .title {
            font-size: 16px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .url {
            font-size: 13px;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        /* --- dialog: remove default white box --- */
        dialog {
            border: none;
            padding: 0;
            background: transparent;
            box-shadow: none;
            max-width: unset;
        }

        dialog::backdrop {
            background: rgba(0, 0, 0, .62)
        }

        .modal {
            width: min(860px, 94vw);
            border: 1px solid var(--stroke);
            border-radius: 22px;
            background: var(--panel);
            padding: 18px;
            color: var(--text);
            margin: 0;
        }

        .modalHead {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px
        }

        .modalTitle {
            font-size: 14px;
            color: var(--muted)
        }

        .iconBtn {
            border: 1px solid var(--stroke);
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            width: 40px;
            height: 40px;
            border-radius: 14px;
            cursor: pointer;
            font-size: 16px;
        }

        .iconBtn:hover {
            background: rgba(255, 255, 255, .10)
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px
        }

        label {
            font-size: 12px;
            color: var(--muted);
            display: grid;
            gap: 8px
        }

        label .input {
            width: 100%
        }

        .hint {
            font-size: 12px;
            color: rgba(159, 176, 197, .85);
            margin-top: -4px
        }

        .modalFoot {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 14px
        }

        .spacer {
            flex: 1
        }

        @media (max-width: 760px) {
            .grid {
                grid-template-columns: 1fr
            }

            .input {
                width: 100%
            }

            .actions {
                flex: 1
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header class="top">
            <div>
                <h1>HomeDash</h1>
                <p class="sub">Local (no server). Right-click a card to edit. Drag cards + categories to reorder.</p>
            </div>

            <div class="actions">
                <input id="search" class="input" placeholder="Search…" />
                <button id="exportBtn" class="btn">Export</button>
                <button id="importBtn" class="btn">Import</button>
                <button id="openAdd" class="btn">Add</button>
            </div>
        </header>

        <main id="content"></main>

        <dialog id="dlg">
            <form id="form" method="dialog" class="modal">
                <div class="modalHead">
                    <div class="modalTitle" id="dlgTitle">Add link</div>
                    <button class="iconBtn" type="button" id="xBtn" aria-label="Close">✕</button>
                </div>

                <div class="grid">
                    <label>Title
                        <input id="title" class="input" required />
                    </label>

                    <label>URL
                        <input id="url" class="input" placeholder="http:// or https:// …" required />
                    </label>

                    <label>Group
                        <input id="grp" class="input" list="groupsList" placeholder="Pick existing or type new…" />
                        <datalist id="groupsList"></datalist>
                    </label>

                    <label>Icon URL (optional)
                        <input id="iconUrl" class="input"
                            placeholder="https://.../icon.png  or  http://192.168.../favicon.ico" />
                        <div class="hint">Tip: for Jellyfin often: http://IP:8096/web/favicon.ico</div>
                    </label>
                </div>

                <div class="modalFoot">
                    <button id="deleteBtn" class="btn danger" type="button" style="display:none">Delete</button>
                    <div class="spacer"></div>
                    <button class="btn ghost" type="button" id="cancelBtn">Cancel</button>
                    <button class="btn" type="submit" id="saveBtn">Save</button>
                </div>
            </form>
        </dialog>

        <input id="filePick" type="file" accept="application/json" style="display:none" />
    </div>

    <script>
        const $ = (id) => document.getElementById(id);

        const LINKS_KEY = "homedash.links.vtest1";
        const GROUPS_KEY = "homedash.groupOrder.vtest1";

        const content = $("content");
        const search = $("search");
        const dlg = $("dlg");
        const form = $("form");
        const dlgTitle = $("dlgTitle");

        const titleEl = $("title");
        const urlEl = $("url");
        const grpEl = $("grp");
        const iconUrlEl = $("iconUrl");

        const openAdd = $("openAdd");
        const cancelBtn = $("cancelBtn");
        const deleteBtn = $("deleteBtn");
        const xBtn = $("xBtn");

        const exportBtn = $("exportBtn");
        const importBtn = $("importBtn");
        const filePick = $("filePick");
        const groupsList = $("groupsList");

        // State
        let links = [];
        let groupOrder = [];
        let editingId = null;

        // DnD state
        let drag = { type: null, id: null, group: null };
        const placeholder = document.createElement("div");
        placeholder.className = "card placeholder";
        placeholder.draggable = false;

        function groupLabel(key) { return key && key.trim() ? key : "Ungrouped"; }
        function groupKeyFromLabel(label) { return label === "Ungrouped" ? "" : (label || "").trim(); }

        function loadJson(key, fallback) {
            try {
                const raw = localStorage.getItem(key);
                return raw ? JSON.parse(raw) : fallback;
            } catch { return fallback; }
        }
        function saveJson(key, value) {
            localStorage.setItem(key, JSON.stringify(value));
        }

        function ensureHttp(url) {
            const u = (url || "").trim();
            if (!u) return "";
            if (/^https?:\/\//i.test(u)) return u;
            return "http://" + u;
        }

        function escapeHtml(s) {
            return String(s).replace(/[&<>"']/g, (c) => ({
                "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;"
            }[c]));
        }

        function isPrivateOrIp(host) {
            if (!host) return true;
            if (host.includes(":")) return true;
            const parts = host.split(".").map(n => Number(n));
            if (parts.length !== 4 || parts.some(n => !Number.isFinite(n))) return false;
            const [a, b] = parts;
            if (a === 10) return true;
            if (a === 192 && b === 168) return true;
            if (a === 172 && b >= 16 && b <= 31) return true;
            if (a === 127) return true;
            return false;
        }

        function iconCandidates(url, title = "") {
            try {
                const u = new URL(url);
                const host = u.hostname;
                const origin = u.origin;
                const t = (title || "").toLowerCase();

                const appSpecific = [];
                if (t.includes("jellyfin") || u.pathname.toLowerCase().includes("jellyfin")) {
                    appSpecific.push(`${origin}/web/favicon.ico`, `${origin}/web/favicon.png`);
                }
                if (t.includes("radarr") || t.includes("sonarr") || t.includes("prowlarr")) {
                    appSpecific.push(`${origin}/Content/Images/favicon.ico`);
                }
                if (t.includes("jellyseerr")) {
                    appSpecific.push(`${origin}/favicon.ico`, `${origin}/favicon.png`);
                }
                if (t.includes("uptime kuma") || t.includes("uptime")) {
                    appSpecific.push(`${origin}/icon.svg`, `${origin}/icon.png`, `${origin}/favicon.ico`);
                }

                const localCommon = [
                    `${origin}/favicon.ico`,
                    `${origin}/favicon.png`,
                    `${origin}/apple-touch-icon.png`,
                    `${origin}/icon.png`,
                    `${origin}/assets/favicon.ico`,
                    `${origin}/assets/favicon.png`,
                    `${origin}/static/favicon.ico`,
                    `${origin}/static/favicon.png`,
                    `${origin}/web/icon.png`,
                    `${origin}/web/favicon.ico`,
                    `${origin}/web/favicon.png`,
                ];

                const external = [];
                if (!isPrivateOrIp(host)) {
                    external.push(
                        `https://icons.duckduckgo.com/ip3/${encodeURIComponent(host)}.ico`,
                        `https://www.google.com/s2/favicons?domain=${encodeURIComponent(host)}&sz=64`
                    );
                }

                const all = [...appSpecific, ...localCommon, ...external];
                return [...new Set(all)];
            } catch {
                return [];
            }
        }

        function firstLetterFor(title, url) {
            const t = (title || "").trim();
            if (t) return t[0].toUpperCase();
            try { return new URL(url).hostname[0].toUpperCase(); } catch { }
            return "★";
        }

        function computeGroupsFromLinks() {
            const set = new Set();
            for (const l of links) {
                const g = (l.grp || "").trim();
                if (g) set.add(g);
            }
            const hasUngrouped = links.some(l => !(l.grp || "").trim());
            if (hasUngrouped) set.add("");
            return [...set];
        }

        function normalizeGroupOrder() {
            const existing = new Set(computeGroupsFromLinks());
            groupOrder = (groupOrder || []).filter(g => existing.has(g));
            for (const g of existing) {
                if (!groupOrder.includes(g)) groupOrder.push(g);
            }
            saveJson(GROUPS_KEY, groupOrder);
            rebuildGroupsDatalist();
        }

        function rebuildGroupsDatalist() {
            const opts = groupOrder
                .slice()
                .filter(g => g !== "")
                .map(g => `<option value="${escapeHtml(g)}"></option>`)
                .join("");
            groupsList.innerHTML = opts;
        }

        function sortLinksInPlace() {
            links.sort((a, b) =>
                (a.grp || "").localeCompare(b.grp || "") ||
                (a.pos ?? 0) - (b.pos ?? 0) ||
                (a.title || "").localeCompare(b.title || ""));
        }

        function renumberPositionsForGroup(groupKey) {
            const arr = links.filter(x => (x.grp || "").trim() === (groupKey || "").trim());
            arr.sort((a, b) => (a.pos ?? 0) - (b.pos ?? 0));
            for (let i = 0; i < arr.length; i++) arr[i].pos = i;
        }

        function persist() {
            saveJson(LINKS_KEY, links);
            saveJson(GROUPS_KEY, groupOrder);
        }

        function matches(item, q) {
            if (!q) return true;
            q = q.toLowerCase();
            return (
                (item.title || "").toLowerCase().includes(q) ||
                (item.url || "").toLowerCase().includes(q) ||
                (item.grp || "").toLowerCase().includes(q)
            );
        }

        function openNew(prefillGroup = "") {
            editingId = null;
            dlgTitle.textContent = prefillGroup ? `Add link → ${groupLabel(prefillGroup)}` : "Add link";
            deleteBtn.style.display = "none";
            titleEl.value = "";
            urlEl.value = "http://";
            grpEl.value = prefillGroup || "";
            iconUrlEl.value = "";
            rebuildGroupsDatalist();
            dlg.showModal();
            titleEl.focus();
        }

        function openEdit(item) {
            editingId = item.id;
            dlgTitle.textContent = "Edit link (right-click card)";
            deleteBtn.style.display = "inline-flex";
            titleEl.value = item.title || "";
            urlEl.value = item.url || "";
            grpEl.value = item.grp || "";
            iconUrlEl.value = item.iconUrl || "";
            rebuildGroupsDatalist();
            dlg.showModal();
        }

        function upsertLink(payload) {
            const g = (payload.grp || "").trim();
            if (!groupOrder.includes(g)) groupOrder.push(g);

            if (!editingId) {
                links.push({ ...payload, id: crypto.randomUUID() });
            } else {
                const i = links.findIndex(x => x.id === editingId);
                if (i >= 0) links[i] = { ...links[i], ...payload };
            }

            renumberPositionsForGroup(g);
            normalizeGroupOrder();
            persist();
            render();
        }

        function removeLink() {
            if (!editingId) return;
            const idx = links.findIndex(x => x.id === editingId);
            if (idx === -1) return;
            const g = (links[idx].grp || "").trim();
            links.splice(idx, 1);
            renumberPositionsForGroup(g);
            normalizeGroupOrder();
            persist();
            render();
        }

        function renameGroup(oldKey) {
            if (oldKey === "") return;
            const next = prompt("Rename category to:", oldKey);
            if (!next) return;
            const newKey = next.trim();
            if (!newKey || newKey === oldKey) return;

            for (const l of links) {
                if ((l.grp || "").trim() === oldKey) l.grp = newKey;
            }

            groupOrder = groupOrder.map(g => g === oldKey ? newKey : g);

            const seen = new Set();
            groupOrder = groupOrder.filter(g => {
                if (seen.has(g)) return false;
                seen.add(g);
                return true;
            });

            renumberPositionsForGroup(newKey);
            normalizeGroupOrder();
            persist();
            render();
        }

        function deleteGroup(gKey) {
            if (!gKey || gKey.trim() === "") return;

            const count = links.filter(l => (l.grp || "").trim() === gKey).length;
            const ok = confirm(
                `Delete category "${gKey}"?\n\nThis will permanently delete ${count} link(s) inside it.\n\nOK = delete category + all links`
            );
            if (!ok) return;

            links = links.filter(l => (l.grp || "").trim() !== gKey);

            groupOrder = groupOrder.filter(g => g !== gKey);

            normalizeGroupOrder();
            persist();
            render();
        }

        // ---- Drag helpers ----
        function cleanupDropStyles() {
            document.querySelectorAll(".group.dropTarget").forEach(el => el.classList.remove("dropTarget"));
            document.querySelectorAll(".gridCards.dropTarget").forEach(el => el.classList.remove("dropTarget"));
        }

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll(".card:not(.placeholder):not(.dragging)")];
            if (!draggableElements.length) return null;

            let closest = null;
            let closestDist = Infinity;

            for (const el of draggableElements) {
                const r = el.getBoundingClientRect();
                const cx = r.left + r.width / 2;
                const cy = r.top + r.height / 2;
                const dx = cx - x;
                const dy = cy - y;
                const dist = dx * dx + dy * dy;
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = el;
                }
            }

            if (!closest) return null;
            const r = closest.getBoundingClientRect();
            const after = (y > r.top + r.height / 2) || (x > r.left + r.width / 2);
            return { el: closest, after };
        }

        function moveLinkToGroupAtIndex(linkId, targetGroup, targetIndex) {
            const i = links.findIndex(l => l.id === linkId);
            if (i === -1) return;

            const moved = links[i];
            const fromGroup = (moved.grp || "").trim();
            const toGroup = (targetGroup || "").trim();

            const fromArr = links.filter(l => (l.grp || "").trim() === fromGroup && l.id !== linkId)
                .sort((a, b) => (a.pos ?? 0) - (b.pos ?? 0));

            const toArr = links.filter(l => (l.grp || "").trim() === toGroup && l.id !== linkId)
                .sort((a, b) => (a.pos ?? 0) - (b.pos ?? 0));

            const idx = Math.max(0, Math.min(targetIndex, toArr.length));

            moved.grp = toGroup;
            toArr.splice(idx, 0, moved);

            for (let k = 0; k < fromArr.length; k++) fromArr[k].pos = k;
            for (let k = 0; k < toArr.length; k++) toArr[k].pos = k;

            if (!groupOrder.includes(toGroup)) groupOrder.push(toGroup);

            normalizeGroupOrder();
            persist();
            render();
        }

        function moveGroup(oldIndex, newIndex) {
            if (oldIndex === newIndex) return;
            if (oldIndex < 0 || newIndex < 0) return;
            const g = groupOrder.splice(oldIndex, 1)[0];
            groupOrder.splice(newIndex, 0, g);
            persist();
            render();
        }

        function render() {
            const q = search.value.trim();
            const filtered = links.filter(x => matches(x, q));

            const map = new Map();
            for (const g of groupOrder) map.set(g, []);
            for (const item of filtered) {
                const g = ((item.grp || "").trim());
                if (!map.has(g)) map.set(g, []);
                map.get(g).push(item);
            }

            content.innerHTML = "";

            if (!filtered.length) {
                const empty = document.createElement("div");
                empty.style.color = "var(--muted)";
                empty.style.padding = "16px";
                empty.textContent = q ? "No matches." : "No links yet — hit Add.";
                content.appendChild(empty);
                return;
            }

            for (let groupIndex = 0; groupIndex < groupOrder.length; groupIndex++) {
                const gKey = groupOrder[groupIndex];
                const items = (map.get(gKey) || []).slice().sort((a, b) => (a.pos ?? 0) - (b.pos ?? 0));

                if (q && items.length === 0) continue;

                const wrap = document.createElement("section");
                wrap.className = "group";
                wrap.dataset.group = gKey;
                wrap.draggable = false;

                wrap.addEventListener("dragover", (e) => {
                    if (drag.type !== "group") return;
                    e.preventDefault();
                    wrap.classList.add("dropTarget");
                });

                wrap.addEventListener("dragleave", () => {
                    if (drag.type !== "group") return;
                    wrap.classList.remove("dropTarget");
                });

                wrap.addEventListener("drop", (e) => {
                    if (drag.type !== "group") return;
                    e.preventDefault();
                    wrap.classList.remove("dropTarget");
                    const from = groupOrder.indexOf(drag.group);
                    const to = groupIndex;
                    if (from !== -1) moveGroup(from, to);
                });

                const head = document.createElement("div");
                head.className = "groupHead";

                const left = document.createElement("div");
                left.className = "groupTitle";

                const handle = document.createElement("div");
                handle.className = "dragHandle";
                handle.title = "Drag to move category";
                handle.innerHTML = `<div class="dragDots"></div>`;

                handle.draggable = true;

                handle.addEventListener("dragstart", (e) => {
                    drag = { type: "group", id: null, group: gKey };
                    wrap.classList.add("dragging");
                    e.dataTransfer.effectAllowed = "move";
                    e.dataTransfer.setData("text/plain", "group");
                });

                handle.addEventListener("dragend", () => {
                    wrap.classList.remove("dragging");
                    cleanupDropStyles();
                    drag = { type: null, id: null, group: null };
                });

                const title = document.createElement("div");
                title.textContent = groupLabel(gKey);

                left.appendChild(handle);
                left.appendChild(title);

                const right = document.createElement("div");
                right.className = "groupRight";

                const count = document.createElement("div");
                count.className = "groupCount";
                count.textContent = String(items.length);

                const addBtn = document.createElement("button");
                addBtn.className = "miniBtn";
                addBtn.type = "button";
                addBtn.textContent = "+ Add";
                addBtn.addEventListener("click", () => openNew(gKey));

                const renameBtn = document.createElement("button");
                renameBtn.className = "miniBtn";
                renameBtn.type = "button";
                renameBtn.textContent = "Rename";
                renameBtn.disabled = (gKey === "");
                renameBtn.style.opacity = (gKey === "" ? ".45" : "1");
                renameBtn.addEventListener("click", () => renameGroup(gKey));

                const delBtn = document.createElement("button");
                delBtn.className = "miniBtn danger";
                delBtn.type = "button";
                delBtn.textContent = "Delete";
                delBtn.disabled = (gKey === "");
                delBtn.style.opacity = (gKey === "" ? ".45" : "1");
                delBtn.addEventListener("click", () => deleteGroup(gKey));

                right.appendChild(count);
                right.appendChild(addBtn);
                right.appendChild(renameBtn);
                right.appendChild(delBtn);

                head.appendChild(left);
                head.appendChild(right);
                wrap.appendChild(head);

                const grid = document.createElement("div");
                grid.className = "gridCards";
                grid.dataset.group = gKey;

                grid.addEventListener("dragover", (e) => {
                    if (drag.type !== "link") return;
                    e.preventDefault();
                    e.dataTransfer.dropEffect = "move";
                    grid.classList.add("dropTarget");

                    const after = getDragAfterElement(grid, e.clientX, e.clientY);
                    if (!grid.contains(placeholder)) grid.appendChild(placeholder);

                    if (after && after.el) {
                        if (after.after) {
                            after.el.insertAdjacentElement("afterend", placeholder);
                        } else {
                            after.el.insertAdjacentElement("beforebegin", placeholder);
                        }
                    } else {
                        grid.appendChild(placeholder);
                    }
                });

                grid.addEventListener("dragleave", () => {
                    if (drag.type !== "link") return;
                    grid.classList.remove("dropTarget");
                });

                grid.addEventListener("drop", (e) => {
                    if (drag.type !== "link") return;
                    e.preventDefault();
                    grid.classList.remove("dropTarget");

                    const children = [...grid.querySelectorAll(".card:not(.dragging)")];
                    const idx = Math.max(0, children.indexOf(placeholder));
                    if (placeholder.parentElement) placeholder.remove();

                    moveLinkToGroupAtIndex(drag.id, gKey, idx);
                    cleanupDropStyles();
                    drag = { type: null, id: null, group: null };
                });

                for (const item of items) {
                    const card = document.createElement("div");
                    card.className = "card";
                    card.dataset.linkId = item.id;
                    card.draggable = true;

                    card.addEventListener("dragstart", (e) => {
                        drag = { type: "link", id: item.id, group: (item.grp || "").trim() };
                        card.classList.add("dragging");
                        e.dataTransfer.effectAllowed = "move";
                        e.dataTransfer.setData("text/plain", "link");
                    });
                    card.addEventListener("dragend", () => {
                        card.classList.remove("dragging");
                        if (placeholder.parentElement) placeholder.remove();
                        cleanupDropStyles();
                        drag = { type: null, id: null, group: null };
                    });

                    const favWrap = document.createElement("div");
                    favWrap.className = "fav";

                    const letterFallback = () => {
                        favWrap.innerHTML = `<div class="letter">${escapeHtml(firstLetterFor(item.title, item.url))}</div>`;
                    };

                    const img = document.createElement("img");
                    img.alt = "";
                    img.loading = "lazy";
                    img.referrerPolicy = "no-referrer";

                    const srcs = [];
                    const iconUrl = (item.iconUrl || "").trim();
                    if (iconUrl) srcs.push(iconUrl);
                    srcs.push(...iconCandidates(item.url, item.title));

                    if (!srcs.length) {
                        letterFallback();
                    } else {
                        img.dataset.srcs = JSON.stringify(srcs);
                        img.dataset.i = "0";
                        img.src = srcs[0];
                        img.addEventListener("error", () => {
                            try {
                                const s = JSON.parse(img.dataset.srcs || "[]");
                                let i = Number(img.dataset.i || "0") + 1;
                                img.dataset.i = String(i);
                                if (i < s.length) img.src = s[i];
                                else letterFallback();
                            } catch {
                                letterFallback();
                            }
                        });
                        favWrap.appendChild(img);
                    }

                    const meta = document.createElement("div");
                    meta.className = "meta";

                    const t = document.createElement("div");
                    t.className = "title";
                    t.textContent = item.title || "";

                    const uline = document.createElement("div");
                    uline.className = "url";
                    try { uline.textContent = new URL(item.url).host; }
                    catch { uline.textContent = item.url; }

                    meta.appendChild(t);
                    meta.appendChild(uline);

                    card.appendChild(favWrap);
                    card.appendChild(meta);

                    card.addEventListener("click", () => window.open(item.url, "_blank", "noopener,noreferrer"));
                    card.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        openEdit(item);
                    });

                    grid.appendChild(card);
                }

                wrap.appendChild(grid);
                content.appendChild(wrap);
            }
        }

        function exportJson() {
            const blob = new Blob([JSON.stringify({ links, groupOrder }, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "homedash-export.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function importJsonFile(file) {
            const r = new FileReader();
            r.onload = () => {
                try {
                    const parsed = JSON.parse(String(r.result || "{}"));

                    let nextLinks = [];
                    let nextGroups = [];

                    if (Array.isArray(parsed)) {
                        nextLinks = parsed;
                    } else {
                        nextLinks = Array.isArray(parsed.links) ? parsed.links : [];
                        nextGroups = Array.isArray(parsed.groupOrder) ? parsed.groupOrder : [];
                    }

                    links = nextLinks.map(x => ({
                        id: x.id || crypto.randomUUID(),
                        title: String(x.title || "").trim(),
                        url: ensureHttp(String(x.url || "").trim()),
                        grp: String(x.grp || "").trim(),
                        pos: Number.isFinite(x.pos) ? Number(x.pos) : 0,
                        iconUrl: String(x.iconUrl || "").trim()
                    })).filter(x => x.title && x.url);

                    groupOrder = nextGroups.map(g => String(g || "").trim());
                    normalizeGroupOrder();

                    for (const g of computeGroupsFromLinks()) renumberPositionsForGroup(g);

                    persist();
                    render();
                } catch (e) {
                    alert("Import failed: " + (e?.message || e));
                }
            };
            r.readAsText(file);
        }

        // ---- UI events ----
        $("openAdd").addEventListener("click", () => openNew(""));
        cancelBtn.addEventListener("click", () => dlg.close());
        xBtn.addEventListener("click", () => dlg.close());

        search.addEventListener("input", render);

        form.addEventListener("submit", (e) => {
            e.preventDefault();

            const payload = {
                title: titleEl.value.trim(),
                url: ensureHttp(urlEl.value.trim()),
                grp: grpEl.value.trim(),
                iconUrl: iconUrlEl.value.trim()
            };

            if (!payload.title || !payload.url) return;

            if (!groupOrder.includes((payload.grp || "").trim())) groupOrder.push((payload.grp || "").trim());

            if (!editingId) {
                const g = (payload.grp || "").trim();
                payload.pos = links.filter(l => (l.grp || "").trim() === g).length;
            }

            dlg.close();
            upsertLink(payload);
        });

        deleteBtn.addEventListener("click", () => {
            if (!confirm("Delete this link?")) return;
            dlg.close();
            removeLink();
        });

        exportBtn.addEventListener("click", exportJson);
        importBtn.addEventListener("click", () => filePick.click());
        filePick.addEventListener("change", () => {
            if (filePick.files?.[0]) importJsonFile(filePick.files[0]);
            filePick.value = "";
        });

        function hardResetDrag() {
            document.querySelectorAll(".card.dragging").forEach(el => el.classList.remove("dragging"));
            document.querySelectorAll(".group.dragging").forEach(el => el.classList.remove("dragging"));
            if (placeholder?.parentElement) placeholder.remove();
            cleanupDropStyles();
            drag = { type: null, id: null, group: null };
        }

        window.addEventListener("blur", hardResetDrag);
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") hardResetDrag();
        });

        // ---- Init ----
        (function init() {
            links = loadJson(LINKS_KEY, null);

            if (!Array.isArray(links)) {
                const v2 = loadJson("homedash.links.v2", []);
                const v1 = loadJson("homedash.links.v1", []);
                links = Array.isArray(v2) && v2.length ? v2 : (Array.isArray(v1) ? v1 : []);
            }

            links = links.map(x => ({
                id: x.id || crypto.randomUUID(),
                title: String(x.title || "").trim(),
                url: ensureHttp(String(x.url || "").trim()),
                grp: String(x.grp || "").trim(),
                pos: Number.isFinite(x.pos) ? Number(x.pos) : 0,
                iconUrl: String(x.iconUrl || "").trim()
            })).filter(x => x.title && x.url);

            groupOrder = loadJson(GROUPS_KEY, null);
            if (!Array.isArray(groupOrder) || groupOrder.length === 0) {
                groupOrder = computeGroupsFromLinks();
            }

            normalizeGroupOrder();
            for (const g of computeGroupsFromLinks()) renumberPositionsForGroup(g);

            persist();
            render();
        })();
    </script>
</body>

</html>